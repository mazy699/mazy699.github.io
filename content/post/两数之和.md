---
title: "两数之和"
date: 2022-05-11T22:31:11+08:00
lastmod: 2022-05-11T22:31:11+08:00
draft: true
keywords: ["LeetCode"]
description: ""
tags: ["LeetCode"]
categories: ["LeetCode"]
author: ""

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
postMetaInFooter: true
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""
typora-root-url: ..\..\static
---

<!--more-->
# 两数之和

### 题目

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>
>  
>
> 示例:
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/two-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

----

### [解决方法](https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/)

##### 方法一：暴力法

​	暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。

```java
class TwoSum {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

##### 复杂度分析：

+ 时间复杂度O(n^2^),

    对于每个元素我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为O(n^2^)。

+ 空间复杂度O(1)。

----

##### 方法二：两遍哈希表

​	在第一次迭代中，我们将每个元素的值和它的索引添加到表中。

​	然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。

``` java
public class TwoSum1 {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

##### 复杂度分析：

+ 时间复杂度O(n),

    我们把包含有 *n* 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。

+ 空间复杂度O(n),

    所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 *n* 个元素。

---

##### 方法三：一遍哈希表

​	在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。

​	如果它存在，那我们已经找到了对应解，并立即将其返回。

---

> [图片来源](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)

1. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/two-sum-1.png)
2. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/two-sum-2.png)
3. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/two-sum-3.png)
4. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/two-sum-4.png)
---

```java
public class TwoSum2 {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

##### 复杂度分析：

+ 时间复杂度O(n),

    我们只遍历了包含有 *n* 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。

+ 空间复杂度O(n),

    所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 *n* 个元素。
