---
title: "顺时针打印矩阵"
date: 2022-05-11T22:35:29+08:00
lastmod: 2022-05-11T22:35:29+08:00
draft: true
keywords: ["LeetCode"]
description: ""
tags: ["LeetCode"]
categories: ["LeetCode"]
author: ""

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
postMetaInFooter: true
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""
typora-root-url: ..\..\static
---

<!--more-->
# 顺时针打印矩阵

### 题目

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
>
>  
>
> 示例 1：
>
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]
> 示例 2：
>
> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
>
>
> 限制：
>
> 0 <= matrix.length <= 100
> 0 <= matrix[i].length <= 100
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

----

### 解决方法

###### 思路

+ 从题目示例可以看出，打印顺序是 **“从左到右，从上到下，从右到左，从下到上”**  。
+ 可以设定四个边界 **left , top , right , bottom** ,遍历要求的打印顺序。
+ [解题图片和代码](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/)，图片很清晰明了，代码也比[自己](.\SpiralOrder.java)的简介



1. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112137939.png)
2. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112137952.png)
3. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112137795.png)
4. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112138324.png)
5. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112138467.png)
6. ![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112138101.png)

| 打印方向 | 1. 根据边界打印           | 2. 边界向内收缩    | 3. 是否打印完毕   |
| -------- | ------------------------- | ------------------ | ----------------- |
| 从左向右 | 左边界left ，右边界 right | 上边界 top 加 1    | 是否 top > bottom |
| 从上向下 | 上边界 top ，下边界bottom | 右边界 right 减 1  | 是否 l eft> right |
| 从右向左 | 右边界 right ，左边界left | 下边界 bottom 减 1 | 是否 top> bottom  |
| 从下向上 | 下边界 bottom ，上边界top | 左边界 left 加 1   | 是否 left> right  |

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0;
        int[] res = new int[(r + 1) * (b + 1)];
        while(true) {
            for(int i = l; i <= r; i++) res[x++] = matrix[t][i]; // left to right.
            if(++t > b) break;
            for(int i = t; i <= b; i++) res[x++] = matrix[i][r]; // top to bottom.
            if(l > --r) break;
            for(int i = r; i >= l; i--) res[x++] = matrix[b][i]; // right to left.
            if(t > --b) break;
            for(int i = b; i >= t; i--) res[x++] = matrix[i][l]; // bottom to top.
            if(++l > r) break;
        }
        return res;
    }
}
```
