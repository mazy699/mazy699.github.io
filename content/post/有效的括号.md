---
title: "有效的括号"
date: 2022-05-11T22:36:46+08:00
lastmod: 2022-05-11T22:36:46+08:00
draft: true
keywords: ["LeetCode"]
description: ""
tags: ["LeetCode"]
categories: ["LeetCode"]
author: ""

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
postMetaInFooter: true
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams: 
  enable: false
  options: ""
typora-root-url: ..\..\static
---

<!--more-->
# 有效的括号

### 题目

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 注意空字符串可被认为是有效字符串。
>
> 示例 1:
>
> 输入: "()"
> 输出: true
> 示例 2:
>
> 输入: "()[]{}"
> 输出: true
> 示例 3:
>
> 输入: "(]"
> 输出: false
> 示例 4:
>
> 输入: "([)]"
> 输出: false
> 示例 5:
>
> 输入: "{[]}"
> 输出: true
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/valid-parentheses
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

### 解决方法

###### 思路

+ 栈先入后出特点正好能满足题目要求，有左括号就入栈，右括号就取栈顶左括号，判断是否有效。
+ 通过Map键值对建立左右括号对应关系。

###### 算法

+ 如果是左括号，就入栈 **push**。
+ 以外就取出栈顶的左括号 **pop**，通过取出的左括号为key在Map中找到对应的value，与当前括号比较。

----

![](https://cdn.jsdelivr.net/gh/mazy699/PicGo@main/img/202205112141581.png)

----

```java
class Solution{
    private HashMap<Character,Character> mappings;
    
    public Solution(){
        this.mappings = new HashMap<Character,Character>();
        this.mappings.put('(', ')');
        this.mappings.put('[', ']');
        this.mappings.put('{', '}');
    }

    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for (Character c : s.toCharArray()) {
            if (mappings.containsKey(c)) {
                stack.push(c);
            } else {
                char top = stack.empty() ? '#' : stack.pop();
                if (c != mappings.get(top)) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```

